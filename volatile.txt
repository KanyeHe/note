1. volatile 是JVM提供的轻量级同步机制，具有3大特性：保证可见性、不保证原子性、禁止指令重排（有序性）。由此可见
volatile其实是不满足JMM规范的。
	a. 可见性：一个线程对变量进行更新操作，其他线程会立马被同步。

2. JMM（Java memory model） ：Java内存模型，本身是一种抽象的概念，并不真是存在，他描述了一组规则（或者规范），
通过这组规则定义了Java中各个变量（包括实例字段，静态字段，以及构成数组对象的元素）的访问方式。JMM规定同步机制
需要满足：可见性、原子性和有序性。

3. JMM关于同步的规定：
	a. 线程解锁前，必须把共享变量的值刷回主内存
	b. 线程加锁前，必须读取主内存的最新值到自己的工作内存
	c. 加锁解锁是同一把锁

4. 由于JVM运行程序的实体是线程，而每个线程创建时，JVM都会为其创建一个工作内存（有的地方叫栈空间），工作内存是每
个线程的私有数据区域，而Java内存模型规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程
对变量的操作（读取赋值等）都必须在自己的工作内存中进行，不能直接操作主内存中变量。所以需要先将变量从住内存拷贝到
工作内存（即工作内存中的变量实际是主内中的一个副本），然后对变量进行操作，操作完成后将变量写会主内存。不同线程间
无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。



